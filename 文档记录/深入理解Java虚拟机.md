# 深入理解Java虚拟机

## Java内存模型

### 程序计数器

程序计数器是一块很小的内存空间，存放字节码指令的地址，字节码解释器通过程序计数器来取下一条需要执行的字节码指令。

每一个线程都有各自的程序计数器。

### Java虚拟机栈

虚拟机栈用来存放被执行的方法中的局部变量、操作数栈、动态链接、方法出口等信息，当一个方法运行时就会入栈，运行完毕则出栈。

每一个线程都有各自的Java虚拟机栈。

### 本地方法栈

虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的本地方法服务。

### Java堆

Java虚拟机内存中最大的一块。所有线程共享一个Java堆。Java堆是垃圾回收器管理的内存区域。可以用通过新生代、老生代、永久代等名字进行划分区域，也可以不同线程在Java对上进行划分私有的缓冲区（TLAB）。Java堆是可以调整的通过 -Xmx 和 -Xms 进行配置。

### 方法区

方法区用来存放类型信息、常量、静态变量以及编译后的代码。JDK8之后使用元空间来替代了。

### 运行时常量池

是方法区的一部分，用来存放编译期生成的各种字面量和符号引用方法区，这部分内容将在类加载后存放到方法区的运行时常量池中。

## JAVA对象创建

Java类从加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：`加载`,`验证`,`准备`,`解析`,`初始化`,`卸载`，总共七个阶段。其中`验证`,`准备`,`解析`统称为 `连接`。而在解析阶段会有一个步将常量池当中二进制数据当中的符号引用转化为直接引用的过程。

- 当虚拟机遇到new指令时，首先去检查指令参数是否能在常量池中定位到一个类的符号引用，并检查符号引用的代表的类是否被加载、解析和初始化过，如果没有就进行相应的类加载过程。
- 类加载检查通过后，为新生对象分配内存。虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
- 内存分配之后，虚拟机将分配到的内存空间都初始化为零，如果使用TLAB的话，提前到TLAB分配时进行。这步确保对象的实例字段在java代码中不赋值直接使用。
- Java虚拟机对对象进行必要的配置。
- 随后开始进行调用构造方法。

## 对象的内存布局

在HotSpot虚拟机中，对象在对内存中的存储布局可以划分为三部分：对象头、实例数据和对齐填充。

对象头包括两类信息。

1. 用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等，数据长度根据32位和64位机器分别为32位和64位的 `“MarkWord”`。

## 对象的访问定位

Java程序会通过栈上的reference数据来操作堆上的具体对象，主流的访问方式主要有使用句柄和直接指针两种：

1. 如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体的地址信息，灵活。![image-20210927093348299](E:\文档记录\img\image-20210927093348299.png)

2. 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何存放访问类型数据的相关信息，reference直接存储对象地址，就无需多一次间接访问，速度快。![image-20210927093719969](E:\文档记录\img\image-20210927093719969.png)

## 判断对象的死活

### 引用计数算法

在对象中添加一个引用计数器，每当有一个地方引用它时，就加一；当一个引用失效时，就减一；任何时刻计数器为零就是不可能在被使用。

但是这种方式很难解决对象之间相互循环引用的问题。

### 可达性分析算法

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下寻找，不可达的对象判定为可回收对象。

![image-20210927094647197](E:\文档记录\img\image-20210927094647197.png)

在java技术体系中，固定可以作为GC Roots的对象包括以下几种：

- 在虚拟机栈中引用的对象。
- 在方法去中类静态属性引用的对象，
- 在方法去中常量引用的对象。
- 在本地方法栈中JNI引用的对象。
- java虚拟机内部的引用。
- 所有被同步锁持有的对象。
- 反应java虚拟机内部情况的JMXBean、本地代码缓存等。

## 引用类型

- 强引用。最传统的引用定义，是指在程序代码之中普遍存在的引用赋值。只要强引用关系存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用。用来描述还有一些作用，但是非必须的对象。只被软引用的对象，在发生内存溢出前会对这些对象进行第二次回收，如果这次回收内存还是不足就抛出异常。
- 弱引用。和软引用相似，只是强度更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生。当垃圾回收器启动时，无论当前内存是否充足都对弱引用的对象进行回收。
- 虚引用。最弱的引用关系，虚引用无法获取一个对象的实例，其目的是在对象被回收时收到一个系统通知。

## 垃圾收集算法

### 标记-清除算法

算法分为“标记”和“清除”两个阶段，首先标记处所有需要回收的对象，也可以反过来标记存活的对象同一回收未被标记的对象。

缺点：执行效率不稳定、产生内存空间的碎片化问题。

![image-20210928161538590](E:\文档记录\img\image-20210928161538590.png)

### 标记-复制算法

为了解决标记清除算法执行效率低的问题而产生。将可用内存按容量划分为相等的两块，每次只是用其中一块，回收时将存活的对象复制到另一块中，然后清除这一块。

![image-20210928162539780](E:\文档记录\img\image-20210928162539780.png)

优点：实现简单、运行高效

缺点：空间浪费太严重。

由于98%的对象都熬不过第一轮的回收，所以不需要按照1:1的比例划分内存空间。在HotSpot中Eden和Survivor的默认比例是8:1，所以每次新生代中的可用内存空间为整个新生代容量的90%。

### 标记-整理算法

标记复制算法在存活率高时效率会低。所以老年代不会使用标记复制算法。针对老年代的特性，”标记-整理“算法得出，其中标记过程还是与”标记-清除“算法一样，但后续的是让所有存货的对象都想内存空间一段移动，然后清除掉边界以外的内存。

![image-20210928163015259](E:\文档记录\img\image-20210928163015259.png)

## 经典的垃圾收集器

收集算法是方法论收集器是实践成果。

![image-20210928164952656](E:\文档记录\img\image-20210928164952656.png)

收集器之间的关系，有连线的是可以配合使用的。

> 并行：描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，同时默认此时用户线程处于等待状态。
>
> 并发：描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾回收器线程与用户线程都在运行。由于系统资源被共用所以吞吐量会受到一定影响。

### Serial收集器（新生代）

Serial收集器是最基础的收集器是jdk1.3.1的之前新生代的唯一选择。这个收集器是单线程工作的收集器，它在进行垃圾收集时，所有其他工作线程都要暂停直到收集完成。

![image-20210928170636902](E:\文档记录\img\image-20210928170636902.png)

> 是HotSpot的默认新生代收集器。

### ParNew收集器（新生代）

ParNew收集器本质上是Serial收集器的多线程并行版本，除了同时使用多线程垃圾收集之外，其余的行为控制参数、收集算法、Stop The World、分配规则、回收策略等都和Serial完全一致。

但是单核情况下不必Serial收集器效果好。

![image-20210928171601832](E:\文档记录\img\image-20210928171601832.png)

> ParNew收集器和Serial收集器能与CMS收集器配合工作。
>
> ParNew收集器是CMS收集器激活后(`-XX: +UseConcMarkSweepGC`)的默认新生代收集器。也可以使用(`-XX: +/-UseParNewGC`)来强制指定或则禁用它。JDK9取消。

### ParallelScavenge收集器（新生代）



它是基于标记复制算法实现的收集器，能够并发收集。它的目标是达到一个可控的吞吐量。
$$
吞吐量=\left(\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}\right)
$$
如果虚拟机完成任务代码加上垃圾收集总耗费100分钟，其中垃圾收集话费1分钟，则吞吐量就是99%。

ParallelScavenge收集器提供两个参数用于精确控制吞吐量，分别是用纸最大垃圾收集停顿时间(`-XX: MaxGCPauseMillis`)以及直接设置吞吐量大小(`-XX: GCTimeRatio`)，还有一个是根据当前设备自适应调节策略(`-XX: +UseAdaptiveSizePolicy`)

### Serial Old收集器（老年代）

Serial收集器的老年代版本。

### Parallel Old收集器（老年代）

ParallelScavenge收集器的老年代版本。

![image-20210929112026290](E:\文档记录\img\image-20210929112026290.png)

### CMS收集器（老年代）

CMS收集器是一种以获取短收回停顿时间为目标的收集器。目前很大一部分的java应用集中于互联网网站或则浏览器的B/S系统的服务端上，这种应用通常会较为关注服务器的相应速度，希望停顿时间短。CMS收集器非常符合这一类应用需求。

![image-20210929164311074](E:\文档记录\img\image-20210929164311074.png)

CMS收集器基于标记清除算法实现的，过程分为四个步骤：

1. 初始标记 ` Stop The World`
2. 并发标记
3. 重新标记 `Stop The World`
4. 并发清除

其中初始标记和重新标记这两步仍然需要暂停其他线程。初始标记仅仅只是标记`GC ROOTs`直接关联的对象，速度很快。

并发标记是从直接直接关联的对象开始遍历整个对象图的过程，时间长但不用停顿用户线程。

重新标记是为了修正并发标记时用户程序导致标记产生变动的那部分对象的标记记录，这阶段需要暂停其他线程，时间稍长。

最后并发清理掉标记的死亡对象。

CMS收集器对处理器资源敏感，因为它默认启动回收线程数为  `(cpu核心数+3)/4` 当处理器核心比较小时对用户程序影响较大。而且CMS无法处理浮动垃圾（程序在标记阶段后重新产生的垃圾）。同时垃圾收集阶段需要预留足够的内存空间给用户线程使用，预留空间可以通过` -XX:CMSInitiatingOccu-pancyFraction`的值进行调整，如果不足会出现”并发失败“启动Serial Old收集器来进行老年代的垃圾回收。因为采用的是标记清除，所以内存碎片会很多。

### Garbage First收集器（G1）

垃圾收集器发展的里程碑，它开创了收集器面向局部收集的设计思路和基于Region(单独区域)的内存分布形式。被称为”全功能的垃圾收集器“，

G1是面向服务端应用的垃圾收集器，是服务端模式下的默认垃圾收集器。

之前的收集器的收集范围要么是整个新生代或者整个老年代以及整个Java堆。G1可以面向对内存任何部分来组成回收集（CSet）进行回收，衡量标准是看那一块内存存的垃圾最多，回收收益最大，这就是G1收集器的`MixedGC`模式。

G1把连续的Java堆划分为多个大小相等的独立区域，每个region都可以根据需要扮演`eden`、`survivor`或者`老年代`空间。如果有对象超过region容量的一半就放入`Humongous`区域。每个region都可以通过`-XX:G1HeapRegionSize`设置，取值在`1MB~32MB`且应为2的N次幂，超大的对象可以存在连续的`Humongous region`中。

![image-20210929191722791](E:\文档记录\img\image-20210929191722791.png)

G1收集器之后以能够建立可预测的停顿时间模型，正是因为使用了region作为最小回收单元，处理思路是让G1收集器去跟踪各个region里面的垃圾堆积价值（回收后获的空间大小以及所需时间的经验值）并维护一个优先级队列，根据用户设定的收集停顿时间（`-XX:MaxGCPauseMillis`,默认200ms）优先回收高价值的region。
